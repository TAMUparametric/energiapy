Index: src/energiapy/components/scenario.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Cost scenario data class\r\n\"\"\"\r\n\r\n__author__ = \"Rahul Kakodkar\"\r\n__copyright__ = \"Copyright 2022, Multi-parametric Optimization & Control Lab\"\r\n__credits__ = [\"Rahul Kakodkar\", \"Efstratios N. Pistikopoulos\"]\r\n__license__ = \"MIT\"\r\n__version__ = \"1.0.5\"\r\n__maintainer__ = \"Rahul Kakodkar\"\r\n__email__ = \"cacodcar@tamu.edu\"\r\n__status__ = \"Production\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, Union\r\n\r\nimport numpy\r\nfrom pandas import DataFrame\r\n\r\nfrom ..components.location import Location\r\nfrom ..components.network import Network\r\nfrom ..components.process import ProcessMode, VaryingProcess\r\nfrom ..components.resource import Resource, VaryingResource\r\nfrom ..components.temporal_scale import TemporalScale\r\n\r\n\r\n@dataclass\r\nclass Scenario:\r\n    \"\"\"\r\n    Scenario contains the network between location and all the data within.\r\n\r\n    Args:\r\n        name (str): name of scenario, short ones are better to deal with.\r\n        scales (temporal_scale): scales of the problem\r\n        network (Union[Network, Location]): network object with the locations, transport linakges, and processes (with resources and materials)\r\n        purchase_scale_level (int, optional): scale for resource purchase. Defaults to 0.\r\n        expenditure_scale_level (int, optional): scale for technology expenditure. Defaults to 0.\r\n        scheduling_scale_level (int, optional): scale of production and inventory scheduling. Defaults to 0.\r\n        network_scale_level (int, optional): scale for network decisions such as facility location. Defaults to 0.\r\n        demand_scale_level (int, optional): scale for meeting specific demand for resource. Defaults to 0.\r\n        cluster_wt (dict): cluster weights as a dictionary. {scale: int}. Defaults to None.\r\n        label (str, optional): Longer descriptive label if required. Defaults to ''\r\n\r\n    Example:\r\n        The Scenario can be built over a single location. The network here is specified as a single Location. Considering scales (TemporalScale object for a year, [1, 365, 24]), scheduling, expenditure, and demand are met at an hourly level, and network at an annual level.\r\n\r\n        >>> Current = Scenario(name= 'current', network= Goa, scales= scales, expenditure_scale_level= 2, scheduling_scale_level= 2, network_scale_level= 0, demand_scale_level= 2, label= 'Current Scenario')\r\n\r\n        A multilocation Scenario needs a Network to be provided. Here, expenditure (on resource purchase) is determined at a daily scale. price_factor in the Location object needs to be commensurate in scale.\r\n\r\n        >>> Future = Scenario(name= 'Future', network= System, scales= scales, expenditure_scale_level= 1, scheduling_scale_level= 2, network_scale_level= 0, demand_scale_level= 2, label= 'Future Scenario )\r\n    \"\"\"\r\n    name: str\r\n    scales: TemporalScale\r\n    network: Union[Network, Location] = None\r\n    purchase_scale_level: int = 0\r\n    expenditure_scale_level: int = 0\r\n    scheduling_scale_level: int = 0\r\n    network_scale_level: int = 0\r\n    demand_scale_level: int = 0\r\n    cluster_wt: dict = None\r\n    demand: Union[Dict[Location, Dict[Resource, float]], float] = None\r\n    label: str = ''\r\n\r\n    def __post_init__(self):\r\n        \"\"\"\r\n        Determines a bunch of handy sets\r\n\r\n        Args:\r\n            transport_set (set): Set of transport options.\r\n            source_locations (set): Set of source locations.\r\n            sink_locations (set): Set of sink locations.\r\n            transport_dict (dict): A dictionary of trasportation modes available between sources to sinks\r\n            transport_avail_dict (dict): A dictionary of available trasportation modes available between sources to sinks.\r\n            transport_max (dict): A dictionary of the maximum amount of each resource that can be transported between sources and sinks.\r\n            transport_loss (dict): A dictionary of the transport losses for each resource that can be transported between sources and sinks.\r\n            transport_cost (dict): A dictionary of the transport cost for each resource that can be transported between sources and sinks.\r\n            transport_cost (dict): A dictionary of the transport emissions for each resource that can be transported between sources and sinks.\r\n            distance_dict (dict): A dictionary of distances between sources and sinks.\r\n            process_set (set): Set of all Process objects.\r\n            resource_set (set): Set of all Resource objects.\r\n            material_set (set): Set of all Material objects.\r\n            conversion (dict): A dictionary with all conversion values for each Process.\r\n            conversion_discharge (dict): A dictionary with all discharge conversions for Process of storage (ProcessMode.STORAGE) type.\r\n            prod_max (dict): A dictionary with maximum production capacity per timeperiod in the network scale for each Process at each Location.\r\n            prod_min (dict): A dictionary with minimum production capacity per timeperiod in the network scale for each Process at each Location.\r\n            cons_max (dict): A dictionary with maximum consumption per timeperiod in the scheduling scale for each Resource at each Location.\r\n            store_max (dict): A dictionary with maximum storage per timeperiod in the scheduling scale for each Resource at each Location.\r\n            store_min (dict): A dictionary with minimum storage per timeperiod in the scheduling scale for each Resource at each Location.\r\n            capacity_factor (dict): A dictionary with Location-wise capacity factors for varying Process objects.\r\n            price_factor (dict): A dictionary with Location-wise cost factors for varying purchase costs of Resource objects.\r\n            demand_factor (dict): A dictionary with Location-wise demand factors for varying demands of Resource objects.\r\n            loc_res_dict (dict): A dictionary with Location-wise availability of Resource objects.\r\n            loc_pro_dict (dict): A dictionary with Location-wise availability of Process objects.\r\n            loc_mat_dict (dict): A dictionary with Location-wise availability of Material objects.\r\n            price (dict): A dictionary with Location-wise cost of Resource objects\r\n            capex_dict (dict): A dictionary with capital expenditure data for each Process.\r\n            fopex_dict (dict): A dictionary with fixed operational expenditure data for each Process.\r\n            vopex_dict (dict): A dictionary with variable operational expenditure data for each Process.\r\n            incidental_dict (dict): A dictionary with incidental expenditure data for each Process.\r\n            land_dict (dict): A dictionary with land use data for each Process.\r\n            material_gwp_dict (dict): A dictionary with global warming potential values for each Material object.\r\n            resource_gwp_dict (dict): A dictionary with global warming potential values for each Resource object.\r\n            process_gwp_dict (dict): A dictionary with global warming potential values for each Process object.\r\n            fail_factor (dict): A dictionary with fail factors for each Process object.\r\n            process_resource_dict (dict): A dictionary with Resource required for each Process.\r\n            process_material_dict (dict): A dictionary with Material required for each Process\r\n            mode_dict (dict): A dictionary with the multiple modes of each Process with ProcessMode.MULTI\r\n        \"\"\"\r\n\r\n        if isinstance(self.network, Location):\r\n            self.transport_set = None\r\n            self.source_locations = None\r\n            self.sink_locations = None\r\n            self.transport_dict = None\r\n            self.transport_avail_dict = None\r\n            self.trans_max = None\r\n            self.trans_loss = None\r\n            self.trans_cost = None\r\n            self.trans_emit = None\r\n            self.distance_dict = None\r\n            self.location_set = {self.network}\r\n\r\n        else:\r\n            self.transport_set = set().union(*self.network.transport_dict.values())\r\n            self.source_locations = self.network.source_locations\r\n            self.sink_locations = self.network.sink_locations\r\n            self.transport_dict = self.network.transport_dict\r\n            self.transport_avail_dict = self.network.transport_avail_dict\r\n            self.location_set = set(self.source_locations + self.sink_locations)\r\n            self.trans_max = {j.name: j.trans_max for j in self.transport_set}\r\n            self.trans_loss = {j.name: j.trans_loss for j in self.transport_set}\r\n            self.trans_cost = {j.name: j.trans_cost for j in self.transport_set}\r\n            self.trans_emit = {j.name: j.trans_emit for j in self.transport_set}\r\n            self.distance_dict = self.network.distance_dict\r\n\r\n        self.process_set = set().union(*[i.processes_full for i in self.location_set if i.processes_full is not None])\r\n        self.resource_set = set().union(*[i.resources_full for i in self.location_set if i.resources is not None])\r\n        self.material_set = set().union(*[i.materials for i in self.location_set if i.materials is not None])\r\n\r\n        self.conversion = {i.name: {j.name: i.conversion[j] if j in i.conversion.keys() \\\r\n            else 0 for j in self.resource_set} for i in self.process_set if i.conversion is not None}\r\n\r\n        self.prod_max = {i.name: i.prod_max for i in self.location_set}\r\n        self.prod_min = {i.name: {j.name: j.prod_min for j in i.processes_full} for i in self.location_set}\r\n        self.cons_max = {i.name: {j.name: j.cons_max for j in i.resources_full} for i in self.location_set}\r\n        self.store_max = {i.name: {j.name: j.store_max for j in i.resources_full} for i in self.location_set}\r\n        self.store_min = {i.name: {j.name: j.store_min for j in i.resources_full} for i in self.location_set}\r\n        self.capacity_factor = {i.name: i.capacity_factor for i in self.location_set}\r\n        self.price_factor = {i.name: i.price_factor for i in self.location_set}\r\n        self.demand_factor = {i.name: i.demand_factor for i in self.location_set}\r\n        self.capex_factor = {i.name: i.capex_factor for i in self.location_set}\r\n        self.vopex_factor = {i.name: i.vopex_factor for i in self.location_set}\r\n        self.fopex_factor = {i.name: i.fopex_factor for i in self.location_set}\r\n        self.loc_res_dict = {i.name: {j.name for j in i.resources_full} for i in self.location_set}\r\n        self.loc_pro_dict = {i.name: {j.name for j in i.processes_full} for i in self.location_set}\r\n        self.loc_mat_dict = {i.name: {j.name for j in i.materials} for i in self.location_set}\r\n        self.price = {i.name: i.resource_price for i in self.location_set}  # TODO change to be location wise\r\n        self.capex_dict = {i.name: i.capex for i in self.process_set}\r\n        self.fopex_dict = {i.name: i.fopex for i in self.process_set}\r\n        self.vopex_dict = {i.name: i.vopex for i in self.process_set}\r\n        self.incidental_dict = {i.name: i.incidental for i in self.process_set}\r\n        self.land_dict = {i.name: i.land for i in self.process_set}\r\n        self.material_gwp_dict = {i.name: {j.name: j.gwp for j in self.material_set} for i in self.location_set}\r\n        self.resource_gwp_dict = {i.name: {j.name: j.gwp for j in self.resource_set} for i in self.location_set}\r\n        self.process_gwp_dict = {i.name: {j.name: j.gwp for j in self.process_set} for i in self.location_set}\r\n        self.land_cost_dict = {i.name: i.land_cost for i in self.location_set}\r\n        self.fail_factor = {i.name: i.fail_factor for i in self.location_set}\r\n\r\n        self.process_resource_dict = {i.name: i.resource_req for i in self.process_set}\r\n\r\n        self.process_material_dict = {i.name: {j.name: i.material_cons[j] for j in i.material_cons.keys()} for i in\r\n                                      self.process_set if i.material_cons is not None}\r\n\r\n        multiconversion_dict = dict()\r\n        for i in self.process_set:\r\n            if i.processmode == ProcessMode.MULTI:\r\n                multiconversion_dict[i.name] = {j: None for j in i.conversion.keys()}\r\n                for k in list(multiconversion_dict[i.name].keys()):\r\n                    multiconversion_dict[i.name][k] = {j.name: i.conversion[k][j] if j in i.conversion[k].keys() else 0\r\n                                                       for j in self.resource_set}\r\n            else:\r\n                multiconversion_dict[i.name] = {0: None}\r\n                multiconversion_dict[i.name][0] = {j.name: i.conversion[j] if j in i.conversion.keys() else 0 for j in\r\n                                                   self.resource_set}\r\n\r\n        self.multiconversion = multiconversion_dict\r\n\r\n        self.mode_dict = {i.name: list(self.multiconversion[i.name].keys()) for i in self.process_set}\r\n\r\n        self.set_dict = {\r\n            'resources': [i.name for i in self.resource_set],\r\n            'resources_nosell': [i.name for i in self.resource_set if i.sell is False],\r\n            'resources_sell': [i.name for i in self.resource_set if i.sell is True],\r\n            'resources_store': [i.name for i in self.resource_set if i.store_max > 0],\r\n            'resources_purch': [i.name for i in self.resource_set if i.cons_max > 0],\r\n            'resources_varying_demand': [i.name for i in self.resource_set if\r\n                                         i.varying == VaryingResource.DETERMINISTIC_DEMAND],\r\n            'resources_varying_price': [i.name for i in self.resource_set if\r\n                                        i.varying == VaryingResource.DETERMINISTIC_PRICE],\r\n            'resources_demand': [i.name for i in self.resource_set if i.demand is True],\r\n            'resources_certain_price': [i.name for i in self.resource_set if (i.varying is None) and (i.cons_max > 0)],\r\n            'resources_uncertain_price': [i.name for i in self.resource_set if\r\n                                          i.varying == VaryingResource.UNCERTAIN_PRICE],\r\n            'resources_certain_demand': [i.name for i in self.resource_set if\r\n                                         (i.varying is None) and (i.demand is True)],\r\n            'resources_uncertain_demand': [i.name for i in self.resource_set if\r\n                                           i.varying == VaryingResource.UNCERTAIN_DEMAND],\r\n            'processes': [i.name for i in self.process_set],\r\n            'processes_full': list(self.conversion.keys()),\r\n            'processes_varying': [i.name for i in self.process_set if\r\n                                  i.varying == VaryingProcess.DETERMINISTIC_CAPACITY],\r\n            'processes_failure': [i.name for i in self.process_set if i.p_fail is not None],\r\n            'processes_materials': [i.name for i in self.process_set if i.material_cons is not None],\r\n            'processes_storage': [i.name for i in self.process_set if i.conversion_discharge is not None],\r\n            'processes_multim': [i.name for i in self.process_set if i.processmode == ProcessMode.MULTI],\r\n            'processes_singlem': [i.name for i in self.process_set if\r\n                                  (i.processmode == ProcessMode.SINGLE) or (i.processmode == ProcessMode.STORAGE)],\r\n            'processes_certain_capacity': [i.name for i in self.process_set if i.varying is None],\r\n            'processes_uncertain_capacity': [i.name for i in self.process_set if\r\n                                             i.varying == VaryingProcess.UNCERTAIN_CAPACITY],\r\n            'locations': [i.name for i in self.location_set],\r\n            'materials': [i.name for i in self.material_set],\r\n        }\r\n\r\n        if self.source_locations is not None:\r\n            self.set_dict['sources'] = [i.name for i in self.source_locations]\r\n        else:\r\n            self.set_dict['sources'] = []\r\n\r\n        if self.sink_locations is not None:\r\n            self.set_dict['sinks'] = [i.name for i in self.sink_locations]\r\n        else:\r\n            self.set_dict['sinks'] = []\r\n\r\n        if self.material_set is not None:\r\n            self.set_dict['materials'] = [i.name for i in self.material_set]\r\n        else:\r\n            self.set_dict['materials'] = []\r\n\r\n        if self.transport_set is not None:\r\n            self.set_dict['transports'] = [i.name for i in self.transport_set]\r\n            self.set_dict['resources_trans'] = [i.name for i in set().union(*[i.resources for i in self.transport_set])]\r\n        else:\r\n            self.set_dict['transports'] = []\r\n            self.set_dict['resources_trans'] = []\r\n\r\n    def make_conversion_df(self) -> DataFrame:\r\n        \"\"\"makes a DataFrame of the conversion values\r\n\r\n        Returns:\r\n            DataFrame: DataFrame of conversion values \r\n        \"\"\"\r\n        return DataFrame.from_dict(self.conversion).transpose()\r\n\r\n    def matrix_form(self):\r\n        \"\"\"returns matrices for the scenario.\r\n\r\n        Returns:\r\n            tuple: A, b, c, H, CRa, CRb, F\r\n        \"\"\"\r\n        demand = self.demand\r\n        if isinstance(demand, dict):\r\n            if isinstance(list(demand.keys())[0], Location):\r\n                self.demand = {i.name: {j.name: demand[i][j] for j in demand[i].keys()} for i in demand.keys()}\r\n        print(demand)\r\n        if len(self.location_set) > 1:\r\n            print(\"can only do this for a single location scenario\")\r\n        else:\r\n            location = list(self.location_set)[0].name\r\n\r\n            # find number of different variables\r\n\r\n            n_Inv = len(self.set_dict['resources_store'])\r\n            n_Sf = len(self.set_dict['resources_certain_demand'])\r\n            n_Cf = len(self.set_dict['resources_certain_price'])\r\n            n_Pf = len(self.set_dict['processes_certain_capacity'])\r\n            n_S = len(self.set_dict['resources_uncertain_demand'])\r\n            n_C = len(self.set_dict['resources_uncertain_price'])\r\n            n_P = len(self.set_dict['processes_uncertain_capacity'])\r\n            n_bal = n_P + n_Pf\r\n\r\n            n_vars_fix = n_Inv + n_Sf + n_Cf + n_Pf\r\n            n_vars_theta = n_S + n_C + n_P\r\n            n_vars = n_vars_fix + n_vars_theta\r\n\r\n            # make b matrix\r\n            # prod max has 0 because the default mode is 0\r\n            b_bal = numpy.zeros((n_bal, 1))\r\n            b_Inv = numpy.array([[self.store_max[location][i]] for i in self.set_dict['resources_store']])\r\n            b_Sf = numpy.array([[-self.demand[location][i]] for i in self.set_dict['resources_certain_demand']])\r\n            b_Cf = numpy.array([[self.cons_max[location][i]] for i in self.set_dict['resources_certain_price']])\r\n            b_Pf = numpy.array([[self.prod_max[location][i][0]] for i in self.set_dict['processes_certain_capacity']])\r\n\r\n            b_S = numpy.array([[-self.demand[location][i]] for i in self.set_dict['resources_uncertain_demand']])\r\n            b_C = numpy.array([[self.cons_max[location][i]] for i in self.set_dict['resources_uncertain_price']])\r\n            b_P = numpy.array([[self.prod_max[location][i][0]] for i in self.set_dict['processes_uncertain_capacity']])\r\n            b_nn = numpy.zeros((n_vars, 1))\r\n\r\n            b_list = [b_bal, b_Inv, b_Sf, b_Cf, b_Pf, b_S, b_C, b_P, b_nn]\r\n\r\n            b = numpy.block([[i] for i in b_list if len(i) > 0])\r\n\r\n            # make F matrix\r\n\r\n            F = numpy.zeros((len(b), n_vars_theta))\r\n\r\n            iter_ = 0\r\n            for i in range(n_S):\r\n                F[n_bal + n_vars_fix + iter_][i] = self.demand[location][self.set_dict['resources_uncertain_demand'][i]]\r\n                iter_ += 1\r\n\r\n            iter_ = 0\r\n            for i in range(n_C):\r\n                F[n_bal + n_vars_fix + n_S + iter_][n_S + i] = self.cons_max[location][\r\n                    self.set_dict['resources_uncertain_price'][i]]\r\n                iter_ += 1\r\n\r\n            iter_ = 0\r\n            for i in range(n_P):\r\n                F[n_bal + n_vars_fix + n_S + n_C + iter_][n_S + n_C + i] = \\\r\n                self.prod_max[location][self.set_dict['processes_uncertain_capacity'][i]][\r\n                    0]  # defaults to 0 as mode, using P_m instead of P\r\n                iter_ += 1\r\n\r\n            # make A matrix\r\n            print(n_Inv, n_Sf, n_Cf, n_S, n_C)\r\n\r\n            A_bal = numpy.diag([*[-1] * n_Inv, *[-1] * n_Sf, *[1] * n_Cf, *[-1] * n_S, *[1] * n_C])\r\n\r\n            A_conv = numpy.array([[self.conversion[i][j] for j in self.conversion[i].keys()] for i in\r\n                                  self.conversion.keys()]).transpose()\r\n\r\n            A_diag = numpy.diag(\r\n                [*[-1] * n_Inv, *[-1] * n_Sf, *[1] * n_Cf, *[1] * n_Pf, *[-1] * n_S, *[1] * n_C, *[1] * n_P])\r\n\r\n            A_nn = numpy.eye(n_vars)\r\n\r\n            print(A_bal)\r\n\r\n            print(A_conv)\r\n\r\n            print(A_diag)\r\n\r\n            print(A_nn)\r\n\r\n            A = numpy.block([[numpy.block([A_bal, A_conv])], [A_diag], [-A_nn]])\r\n\r\n            # make c matrix\r\n\r\n            c_Inv = numpy.zeros((n_Inv, 1))\r\n            c_Sf = numpy.zeros((n_Sf, 1))\r\n            c_Cf = numpy.zeros((n_Cf, 1))\r\n            c_Pf = numpy.array([[self.capex_dict[i]] for i in self.set_dict['processes_certain_capacity']])\r\n\r\n            c_S = numpy.zeros((n_S, 1))\r\n            c_C = numpy.zeros((n_C, 1))\r\n            c_P = numpy.array([[self.capex_dict[i]] for i in self.set_dict['processes_uncertain_capacity']])\r\n\r\n            c_list = [c_Inv, c_Sf, c_Cf, c_Pf, c_S, c_C, c_P]\r\n            c = numpy.block([[i] for i in c_list if len(i) > 0])\r\n\r\n            # make H matrix\r\n\r\n            H = numpy.zeros((A.shape[1], F.shape[1]))\r\n\r\n            # make critical regions\r\n\r\n            CRa = numpy.vstack((numpy.eye(n_vars_theta), -numpy.eye(n_vars_theta)))\r\n            CRb = numpy.array([*[1] * n_vars_theta, *[0] * n_vars_theta]).reshape(n_vars_theta * 2, 1)\r\n\r\n            return A, b, c, H, CRa, CRb, F\r\n\r\n    def __repr__(self):\r\n        return self.name\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/energiapy/components/scenario.py b/src/energiapy/components/scenario.py
--- a/src/energiapy/components/scenario.py	(revision dc4cfad32503adc6c5d48111415540844dfb7e0d)
+++ b/src/energiapy/components/scenario.py	(date 1680895070423)
@@ -74,7 +74,7 @@
             transport_max (dict): A dictionary of the maximum amount of each resource that can be transported between sources and sinks.
             transport_loss (dict): A dictionary of the transport losses for each resource that can be transported between sources and sinks.
             transport_cost (dict): A dictionary of the transport cost for each resource that can be transported between sources and sinks.
-            transport_cost (dict): A dictionary of the transport emissions for each resource that can be transported between sources and sinks.
+            transport_emit (dict): A dictionary of the transport emissions for each resource that can be transported between sources and sinks.
             distance_dict (dict): A dictionary of distances between sources and sinks.
             process_set (set): Set of all Process objects.
             resource_set (set): Set of all Resource objects.
